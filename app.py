# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gqCVQvBMIbf1WsZqer0EXwcf_R5RzdZR
"""


import dash
import pandas as pd
import numpy as np
import dash_auth
from dash import html, dcc, Input, Output
import plotly.express as px
from sklearn.ensemble import IsolationForest



#file_path = '/content/drive/My Drive/D√©tection_Anomalies_Tableaux_de_bord/data/Extractions.xlsx'

# Lire le fichier
#df = pd.read_excel(file_path)

# Afficher les 5 premi√®res lignes
#print(df.head())

# Nettoyage automatique des noms de colonnes
df.columns = df.columns.str.strip()           # Supprime les espaces autour
df.columns = df.columns.str.replace('\u00a0', ' ')  # Remplace les espaces ins√©cables par des espaces normaux
df.columns = df.columns.str.replace('\t', '') # Supprime les tabulations si pr√©sentes

# V√©rifier les noms nettoy√©s
print("Colonnes apr√®s nettoyage :", df.columns.tolist())

# 6. Remplacer tous les NaN par une cha√Æne vide
df = df.fillna('')

# Nettoyage des colonnes et parsing des dates
df = df.rename(columns=lambda x: x.strip())
df.fillna("", inplace=True)
df['Date_Demande'] = pd.to_datetime(df['Date_Demande'], errors='coerce', dayfirst=True)
df['Date_Paiement'] = pd.to_datetime(df['Date_Paiement'], errors='coerce', dayfirst=True)
df['Debut_Inspection'] = pd.to_datetime(df['Debut_Inspection'], errors='coerce', dayfirst=True)
df['Fin_Inspection'] = pd.to_datetime(df['Fin_Inspection'], errors='coerce', dayfirst=True)
df['Cloture_le'] = pd.to_datetime(df['Cloture_le'], errors='coerce', dayfirst=True)

# Cr√©ation des colonnes utiles
df["Debut_Inspection"] = pd.to_datetime(df["Debut_Inspection"], errors='coerce')
df["Fin_Inspection"] = pd.to_datetime(df["Fin_Inspection"], errors='coerce')

# Calcul de la dur√©e d'inspection (en minutes)
df['Duree_Inspection'] = (df['Fin_Inspection'] - df['Debut_Inspection']).dt.total_seconds() / 60

# Ajout d‚Äôune cha√Æne lisible pour affichage
df['Duree_Inspection_str'] = df['Duree_Inspection'].apply(
    lambda x: f"{x:.2f} min" if pd.notna(x) else "N/A"
)
# === Analyse par inspecteur ===
def classer_duree(duree):
    if pd.isna(duree):
        return "Inconnue"
    elif duree < 15:
        return "Trop court"
    elif duree > 1000:
        return "Trop long"
    else:
        return "Normal"

df["Classe"] = df["Duree_Inspection"].apply(classer_duree)

# √âtape 1 : Mod√®le IsolationForest
iso_model = IsolationForest(contamination=0.01, random_state=42)
features = df[['Duree_Inspection']].replace([np.inf, -np.inf], np.nan).dropna()
df['Anomalie'] = 'Normale'
df.loc[features.index, 'Anomalie'] = iso_model.fit_predict(features)
df['Anomalie'] = df['Anomalie'].map({1: 'Normale', -1: 'Suspecte'})

# √âtape 2 : Ajouter r√®gle m√©tier pour forcer certains cas en "Suspecte"
df['Anomalie'] = df.apply(
    lambda row: 'Suspecte' if pd.notnull(row['Duree_Inspection']) and (row['Duree_Inspection'] < 15 or row['Duree_Inspection'] > 1000) else row['Anomalie'],
    axis=1
)

df.sample(10)

# Cr√©ation de la colonne "Mois"
df["Mois"] = pd.to_datetime(df["Date_Demande"], errors='coerce').dt.to_period("M")

# === Statistiques compl√©mentaires ===
demandes_par_mois = df.groupby('Mois').size().reset_index(name='Nombre')
demandes_par_agence = df.groupby('Agence').size().reset_index(name='Nombre')

anomalies_par_mois = df.groupby('Mois')['Anomalie'].value_counts().unstack().fillna(0)
anomalies_par_mois['Taux_Suspect'] = anomalies_par_mois['Suspecte'] / (
    anomalies_par_mois['Suspecte'] + anomalies_par_mois['Normale']
) * 100
anomalies_par_mois = anomalies_par_mois.reset_index()

# Classification selon le Taux d'anomalies par mois
def couleur_taux(taux):
    if taux > 3:
        return 'red'
    elif taux > 1:
        return 'orange'
    else:
        return 'green'

anomalies_par_mois['Couleur'] = anomalies_par_mois['Taux_Suspect'].apply(couleur_taux)

# Avant un graphique ou une dropdown
df['Mois'] = df['Mois'].astype(str)
# Nombre de demandes par mois
demandes_par_mois = df.groupby("Mois").size().reset_index(name="Nombre")
demandes_par_mois["Mois"] = demandes_par_mois["Mois"].astype(str)

# Nombre de demandes par agence
demandes_par_agence = df.groupby("Agence").size().reset_index(name='Nombre')



# Liste des points de conformit√© majeurs (√† adapter selon les noms de colonnes si disponibles)
points_essentiels = ['prise de terre', 'diff√©rentiel', 'disjoncteur de branchement']

# Exemple hypoth√©tique : Tu dois avoir une colonne indiquant les remarques de l‚Äôinspecteur (ex: "Non conforme - prise de terre non pos√©e")
def detecter_fraude(row):
    remarque = str(row.get('Remarque_Inspecteur', '')).lower()
    statut_final = str(row.get('Etat_Demande', '')).lower()

    for point in points_essentiels:
        if point in remarque and "non conforme" in remarque:
            if statut_final == "conforme":
                return "Fraude"
    return "R.A.S"

df['Fraude'] = df.apply(detecter_fraude, axis=1)


import dash
from dash import html, dcc, Input, Output
import plotly.express as px
import pandas as pd
import dash_table


# ‚ûï Convertir Mois en string (√©vite l'erreur "Period not JSON serializable")
df["Mois"] = df["Mois"].astype(str)

# ‚ûï Classification dur√©e inspection
def classer_duree(duree):
    if pd.isna(duree):
        return "Inconnue"
    elif duree < 10:
        return "Trop court"
    elif duree > 1000:
        return "Trop long"
    else:
        return "Normal"

df['Classe'] = df['Duree_Inspection'].apply(classer_duree)

# üßÆ Moyenne par inspecteur
moyenne_par_inspecteur = df.groupby('Inspecteur')['Duree_Inspection'].mean().reset_index()
moyenne_par_inspecteur['Classe'] = moyenne_par_inspecteur['Duree_Inspection'].apply(classer_duree)

# üìä Nombre de demandes par mois
demandes_par_mois = df.groupby("Mois").size().reset_index(name="Nombre")

# üìä Nombre de demandes par agence
demandes_par_agence = df.groupby("Agence").size().reset_index(name="Nombre")

# üìä Anomalies par mois
anomalies_par_mois = df.groupby("Mois")["Anomalie"].value_counts().unstack().fillna(0)
anomalies_par_mois["Taux_Suspect"] = anomalies_par_mois["Suspecte"] / (
    anomalies_par_mois["Suspecte"] + anomalies_par_mois["Normale"]) * 100
anomalies_par_mois = anomalies_par_mois.reset_index()

# Identifiants autoris√©s (username:password)
VALID_USERNAME_PASSWORD_PAIRS = {
    'admin': 'Cos2025'
}

# üèÅ Initialiser l‚Äôapplication Dash
app = dash.Dash(__name__)
auth = dash_auth.BasicAuth(app, VALID_USERNAME_PASSWORD_PAIRS)
server = app.server  # N√©cessaire pour Render
app.title = "Analyse COSSUEL"

# üé® Interface utilisateur
app.layout = html.Div([
    html.H1("üîí Tableau de Bord S√©curis√©"),
    html.H2("üìä Tableaux de Bord - Analyse des demandes COSSUEL"),

    dcc.Graph(id='graph-demandes', figure=px.bar(demandes_par_mois, x='Mois', y='Nombre',
                                                 title="Demandes par Mois")),

    html.H4("üïí Dur√©e moyenne par inspecteur - Classification"),
    dcc.Graph(figure=px.bar(moyenne_par_inspecteur, x='Inspecteur', y='Duree_Inspection',
                            color='Classe',
                            title="Dur√©e Moyenne des Inspections par Inspecteur",
                            labels={"Duree_Inspection": "Dur√©e Moyenne (min)"})),

    html.H4("üè¢ Nombre de demandes par agence"),
    dcc.Graph(figure=px.bar(demandes_par_agence, x='Agence', y='Nombre',
                            title="Nombre de Demandes par Agence")),

    html.H4("üö® Taux d'anomalies suspectes par mois"),
    dcc.Graph(figure=px.line(anomalies_par_mois, x='Mois', y='Taux_Suspect',
                             title="Taux d'Anomalies Suspectes (%)", markers=True)),

    html.H4("üîç S√©lection d‚Äôun mois pour affichage des anomalies"),
    dcc.Dropdown(
        options=[{"label": m, "value": m} for m in sorted(df["Mois"].unique())],
        value=sorted(df["Mois"].unique())[-1],
        id='mois-selection'
    ),

    dcc.Graph(id='graph-anomalies'),

    html.Hr(),

    html.H4("üïµÔ∏è Alerte dur√©e d‚Äôinspection - Simulation de saisie"),
    html.Label("S√©lectionnez un inspecteur :"),
    dcc.Dropdown(
        id='inspecteur-dropdown-1',
        options=[{'label': i, 'value': i} for i in moyenne_par_inspecteur['Inspecteur']],
        value=None,
        placeholder="Choisissez un inspecteur"
    ),

    html.Div(id='alerte-inspection'),

    html.H4("Cas de fraude d√©tect√©s (Inspecteur VS R√©f√©rent)"),
    dcc.Graph(figure=px.bar(df[df['Fraude'] == "Fraude"],
                        x='Inspecteur',
                        title="Cas de fraude d√©tect√©s par Inspecteur",
                        labels={'Inspecteur': 'Inspecteur'})),

    html.H4("D√©tails des cas suspects de cl√¥ture conforme malgr√© anomalie"),
    dash_table.DataTable(
        columns=[{"name": i, "id": i} for i in ['N¬∞ Demande', 'Inspecteur', 'Etat_Demande', 'Remarque_Inspecteur']],
        data=df[df['Fraude'] == "Fraude"].to_dict('records'),
        page_size=10,
        style_table={'overflowX': 'auto'},
        style_cell={'textAlign': 'left'}
    ),

    html.Div([
        html.H4(f"Nombre total de fraudes d√©tect√©es : {df[df['Fraude'] == 'Fraude'].shape[0]}")
    ]),

    html.H4("üïµÔ∏è Saisie de rapport d‚Äôinspection - Simulation"),
    html.Label("S√©lectionnez un inspecteur :"),
    dcc.Dropdown(
        id='inspecteur-dropdown-2',
        options=[{'label': i, 'value': i} for i in moyenne_par_inspecteur['Inspecteur']],
        value=None,
        placeholder="Choisissez un inspecteur"
    ),
    html.Div(id='alerte-inspection-saisie')
])

# üîÅ Callback pour le graphe des anomalies par mois
@app.callback(
    Output('graph-anomalies', 'figure'),
    Input('mois-selection', 'value')
)
def afficher_anomalies(mois):
    df_mois = df[df['Mois'] == mois]
    fig = px.scatter(df_mois, x='Debut_Inspection', y='Duree_Inspection', color='Anomalie',
                     title=f"D√©tection d'anomalies - {mois}",
                     labels={"Duree_Inspection": "Dur√©e (min)", "Debut_Inspection": "D√©but Inspection"})
    return fig

# üîÅ Callback 1 ‚Äì pour alerte dur√©e inspection (dropdown 1)
@app.callback(
    Output('alerte-inspection', 'children'),
    Input('inspecteur-dropdown-1', 'value')
)
def verifier_duree(inspecteur):
    if inspecteur is None:
        return ""
    duree = moyenne_par_inspecteur.loc[
        moyenne_par_inspecteur['Inspecteur'] == inspecteur, 'Duree_Inspection'].values[0]
    if duree < 10:
        couleur = 'red'
        message = f"‚ö†Ô∏è Dur√©e trop courte ({duree:.2f} min) ‚Äî Inspection suspecte !"
    elif duree > 1000:
        couleur = 'orange'
        message = f"‚ö†Ô∏è Dur√©e trop longue ({duree:.2f} min) ‚Äî Inspection anormale !"
    else:
        couleur = 'green'
        message = f"‚úÖ Dur√©e normale ({duree:.2f} min)."
    return html.Div(message, style={'color': couleur, 'fontWeight': 'bold'})

# üîÅ Callback 2 ‚Äì pour alerte saisie rapport (dropdown 2)
@app.callback(
    Output('alerte-inspection-saisie', 'children'),
    Input('inspecteur-dropdown-2', 'value')
)
def verifier_duree_saisie(inspecteur):
    if inspecteur is None:
        return ""
    duree = moyenne_par_inspecteur.loc[
        moyenne_par_inspecteur['Inspecteur'] == inspecteur, 'Duree_Inspection'].values[0]
    if duree < 10:
        couleur = 'red'
        message = f"‚ö†Ô∏è Dur√©e d‚Äôinspection trop courte ({duree:.2f} min). Veuillez v√©rifier."
    elif duree > 1000:
        couleur = 'orange'
        message = f"‚ö†Ô∏è Dur√©e d‚Äôinspection tr√®s longue ({duree:.2f} min). Cela semble anormal."
    else:
        couleur = 'green'
        message = f"‚úÖ Dur√©e d‚Äôinspection normale ({duree:.2f} min)."
    return html.Div(message, style={'color': couleur, 'fontWeight': 'bold'})

# üöÄ Lancer l'application
if __name__ == '__main__':
    app.run_server(debug=True)

